# -*- coding: utf-8 -*-
"""cv_project1_eigenface.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w99W4e6gnqKV1kxSoh8NPj11vPXzkuQ9

# Eigen face method on AT & T dataset
"""

#Mount google drive
from google.colab import drive
drive.mount('/content/drive')
# path = "/content/drive/MyDrive/computer_vision/project1/AT_T"


import zipfile
import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA

# Read face image from zip file on the fly
faces = {}
with zipfile.ZipFile(r"/content/drive/MyDrive/computer_vision/project1/attface.zip") as facezip:
    for filename in facezip.namelist():
        if not filename.endswith(".pgm"):
            continue # not a face picture
        with facezip.open(filename) as image:
            # If we extracted files from zip, we can use cv2.imread(filename) instead
            faces[filename] = cv2.imdecode(np.frombuffer(image.read(), np.uint8), cv2.IMREAD_GRAYSCALE)

# Show sample faces using matplotlib
fig, axes = plt.subplots(4,4,sharex=True,sharey=True,figsize=(8,10))
faceimages = list(faces.values())[-16:] # take last 16 images
for i in range(16):
    axes[i%4][i//4].imshow(faceimages[i], cmap="gray")
print("Showing sample faces")
plt.show()

# Print some details
faceshape = list(faces.values())[0].shape
print("Face image shape:", faceshape)

classes = set(filename.split("/")[0] for filename in faces.keys())
print("Number of classes:", len(classes))
print("Number of images:", len(faces))

# Take classes 1-39 for eigenfaces, keep entire class 40 and
# image 10 of class 39 as out-of-sample test
facematrix = []
facelabel = []
for key,val in faces.items():
    if key.startswith("s40/"):
        continue # this is our test set
    if key == "s39/10.pgm":
        continue # this is our test set
    if key == "s3/10.pgm":
        continue # this is our test set
    if key == "s4/10.pgm":
        continue # this is our test set
    if key == "s5/10.pgm":
        continue # this is our test set
    if key == "s6/10.pgm":
        continue # this is our test set
    if key == "s7/10.pgm":
        continue # this is our test set
    if key == "s8/10.pgm":
        continue # this is our test set
    if key == "s9/10.pgm":
        continue # this is our test set
    if key == "s23/10.pgm":
        continue # this is our test set
    if key == "s24/10.pgm":
        continue # this is our test set
    if key == "s25/10.pgm":
        continue # this is our test set
    if key == "s26/10.pgm":
        continue # this is our test set
    if key == "s27/10.pgm":
        continue # this is our test set
    if key == "s28/10.pgm":
        continue # this is our test set
    if key == "s29/10.pgm":
        continue # this is our test set
    if key == "s30/10.pgm":
        continue # this is our test set
    if key == "s31/10.pgm":
        continue # this is our test set
    if key == "s32/10.pgm":
        continue # this is our test set
    if key == "s33/10.pgm":
        continue # this is our test set
    if key == "s34/10.pgm":
        continue # this is our test set
    if key == "s35/10.pgm":
        continue # this is our test set
    if key == "s36/10.pgm":
        continue # this is our test set
    if key == "s37/10.pgm":
        continue # this is our test set
    if key == "s38/10.pgm":
        continue # this is our test set
    facematrix.append(val.flatten())
    facelabel.append(key.split("/")[0])
# test labels:
test_labels = ["s39","s3","s4","s5","s6","s7","s8","s9","s23","s24","s25","s26","s27","s28","s29","s30","s31","s32","s33","s34","s35","s36","s37","s38"]
test_imgs = ["s39/10.pgm","s3/10.pgm","s4/10.pgm","s5/10.pgm","s6/10.pgm","s7/10.pgm","s8/10.pgm","s9/10.pgm","s23/10.pgm","s24/10.pgm","s25/10.pgm","s26/10.pgm","s27/10.pgm","s28/10.pgm","s29/10.pgm","s30/10.pgm","s31/10.pgm","s32/10.pgm","s33/10.pgm","s34/10.pgm","s35/10.pgm","s36/10.pgm","s37/10.pgm","s38/10.pgm"]
# Create a NxM matrix with N images and M pixels per image
facematrix = np.array(facematrix)

# Apply PCA and take first K principal components as eigenfaces
pca = PCA().fit(facematrix)

n_components = 50
eigenfaces = pca.components_[:n_components]

# Show the first 16 eigenfaces
fig, axes = plt.subplots(4,4,sharex=True,sharey=True,figsize=(8,10))
for i in range(16):
    axes[i%4][i//4].imshow(eigenfaces[i].reshape(faceshape), cmap="gray")
print("Showing the eigenfaces")
plt.show()

# Generate weights as a KxN matrix where K is the number of eigenfaces and N the number of samples
weights = eigenfaces @ (facematrix - pca.mean_).T
print("Shape of the weight matrix:", weights.shape)

# Test on out-of-sample image of existing class
result =[]
for i in test_imgs:
    #
    query = faces[i].reshape(1,-1)
    query_weight = eigenfaces @ (query - pca.mean_).T
    euclidean_distance = np.linalg.norm(weights - query_weight, axis=0)
    best_match = np.argmin(euclidean_distance)
    result.append(facelabel[best_match])
    print("Best match %s with Euclidean distance %f" % (facelabel[best_match], euclidean_distance[best_match]))
    # Visualize
    fig, axes = plt.subplots(1,2,sharex=True,sharey=True,figsize=(8,6))
    axes[0].imshow(query.reshape(faceshape), cmap="gray")
    axes[0].set_title("Query")
    axes[1].imshow(facematrix[best_match].reshape(faceshape), cmap="gray")
    axes[1].set_title("Best match")
    plt.show()

# Test on out-of-sample image of new class
query = faces["s40/1.pgm"].reshape(1,-1)
query_weight = eigenfaces @ (query - pca.mean_).T
euclidean_distance = np.linalg.norm(weights - query_weight, axis=0)
best_match = np.argmin(euclidean_distance)
print("Best match %s with Euclidean distance %f" % (facelabel[best_match], euclidean_distance[best_match]))
# Visualize
fig, axes = plt.subplots(1,2,sharex=True,sharey=True,figsize=(8,6))
axes[0].imshow(query.reshape(faceshape), cmap="gray")
axes[0].set_title("Query")
axes[1].imshow(facematrix[best_match].reshape(faceshape), cmap="gray")
axes[1].set_title("Best match")
plt.show()

print(result,"\n",test_labels)

import numpy as np
from sklearn.metrics import accuracy_score

acc = accuracy_score(test_labels, result)
print("Accuracy is ",acc)

from sklearn.metrics import confusion_matrix
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
y_test = test_labels
y_pred = result
cm = confusion_matrix(y_test, y_pred)
print("Confusion matrix:")
print(cm)
precision = precision_score(y_test, y_pred,average='macro')
print("Precision:")
print(precision)
recall = recall_score(y_test, y_pred,average='macro')
print("Recall:")
print(recall)
f1_score = f1_score(y_test, y_pred,average='macro')
print("F1 score:")
print(f1_score)



"""# Eigen face method on ORL dataset

"""

#Mount google drive
from google.colab import drive
drive.mount('/content/drive')
path = "/content/drive/MyDrive/computer_vision/project1/orl"


import zipfile
import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA

import os
faces = {}
list1 = os.listdir(path)
# list1.sort()
for i in list1:
    img = cv2.imread(os.path.join(path,i)) # read image
    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # transform to grayscale
    img = cv2.resize(img, (80, 80), interpolation = cv2.INTER_AREA) # resize to 80x80
    faces[i] = img

# Show sample faces using matplotlib
fig, axes = plt.subplots(4,4,sharex=True,sharey=True,figsize=(8,10))
faceimages = list(faces.values())[-16:] # take last 16 images
for i in range(16):
    axes[i%4][i//4].imshow(faceimages[i], cmap="gray")
print("Showing sample faces")
plt.show()

# Print some details
faceshape = list(faces.values())[0].shape
print("Face image shape:", faceshape)

classes = set(filename.split(".")[0].split('_')[1] for filename in faces.keys())
print("Number of classes:", len(classes),classes)
print("Number of images:", len(faces))

faces_key = list(faces.keys())
test_keys = set()
for i in range(len(faces_key)):
    num=faces_key[i].split("_")[0]
    if int(num)%10==0:
        test_keys.add(faces_key[i])
class_41 = set(['401_41.jpg', '402_41.jpg', '403_41.jpg', '404_41.jpg', '405_41.jpg', '406_41.jpg', '407_41.jpg', '408_41.jpg', '409_41.jpg', '410_41.jpg'])
for j in class_41:
    test_keys.add(j)
print(test_keys)


# Take classes 1-40 for eigenfaces, keep entire class 41 and
# image 10 of class 39 as out-of-sample test
facematrix = []
facelabel = []
for key,val in faces.items():
    if key in test_keys:
        continue # this is our test set
    facematrix.append(val.flatten())
    facelabel.append(key.split(".")[0].split("_")[1])

print(len(facelabel),facelabel)

# test labels:
test_labels = []
test_images = []
for i in class_41:
    test_keys.remove(i)
#print(len(test_keys),test_keys)
for i in test_keys:
    test_images.append(i)
    test_labels.append( i.split(".")[0].split("_")[1] )
print("test_images:",test_images)
print("test_labels:",test_labels)

# Create a NxM matrix with N images and M pixels per image
facematrix = np.array(facematrix)

# Apply PCA and take first K principal components as eigenfaces
pca = PCA().fit(facematrix)

n_components = 50
eigenfaces = pca.components_[:n_components]

# Show the first 16 eigenfaces
fig, axes = plt.subplots(4,4,sharex=True,sharey=True,figsize=(8,10))
for i in range(16):
    axes[i%4][i//4].imshow(eigenfaces[i].reshape(faceshape), cmap="gray")
print("Showing the eigenfaces")
plt.show()

# Generate weights as a KxN matrix where K is the number of eigenfaces and N the number of samples
weights = eigenfaces @ (facematrix - pca.mean_).T
print("Shape of the weight matrix:", weights.shape)

# Test on out-of-sample image of existing class
result =[]
for i in test_images:
    #
    query = faces[i].reshape(1,-1)
    query_weight = eigenfaces @ (query - pca.mean_).T
    euclidean_distance = np.linalg.norm(weights - query_weight, axis=0)
    best_match = np.argmin(euclidean_distance)
    result.append(facelabel[best_match])
    print("Best match %s with Euclidean distance %f" % (facelabel[best_match], euclidean_distance[best_match]))
    # Visualize
    fig, axes = plt.subplots(1,2,sharex=True,sharey=True,figsize=(8,6))
    axes[0].imshow(query.reshape(faceshape), cmap="gray")
    axes[0].set_title("Query")
    axes[1].imshow(facematrix[best_match].reshape(faceshape), cmap="gray")
    axes[1].set_title("Best match")
    plt.show()

# Test on out-of-sample image of new class
query = faces["410_41.jpg"].reshape(1,-1)
query_weight = eigenfaces @ (query - pca.mean_).T
euclidean_distance = np.linalg.norm(weights - query_weight, axis=0)
best_match = np.argmin(euclidean_distance)
print("Best match %s with Euclidean distance %f" % (facelabel[best_match], euclidean_distance[best_match]))
# Visualize
fig, axes = plt.subplots(1,2,sharex=True,sharey=True,figsize=(8,6))
axes[0].imshow(query.reshape(faceshape), cmap="gray")
axes[0].set_title("Query")
axes[1].imshow(facematrix[best_match].reshape(faceshape), cmap="gray")
axes[1].set_title("Best match")
plt.show()#Mount google drive



import numpy as np
from sklearn.metrics import accuracy_score

acc = accuracy_score(test_labels, result) 
print("Accuracy is ", acc)

from sklearn.metrics import confusion_matrix
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
y_test = test_labels
y_pred = result
cm = confusion_matrix(y_test, y_pred)
print("Confusion matrix:")
print(cm)
precision = precision_score(y_test, y_pred,average='macro')
print("Precision:")
print(precision)
recall = recall_score(y_test, y_pred,average='macro')
print("Recall:")
print(recall)
f1_score = f1_score(y_test, y_pred,average='macro')
print("F1 score:")
print(f1_score)

"""# Eigenface method on IITJ campus collected dataset"""

#Mount google drive
from google.colab import drive
drive.mount('/content/drive')
path = "/content/drive/MyDrive/computer_vision/project1/own_dataset_rj"

import zipfile
import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA

import os
faces = {}
list1 = os.listdir(path)
# list1.sort()
for i in list1:
    img = cv2.imread(os.path.join(path,i)) # read image
    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # transform to grayscale
    img = cv2.resize(img, (100, 100), interpolation = cv2.INTER_AREA) # resize to 80x80
    faces[i] = img

# Show sample faces using matplotlib
fig, axes = plt.subplots(4,4,sharex=True,sharey=True,figsize=(8,10))
faceimages = list(faces.values())[-16:] # take last 16 images
for i in range(16):
    axes[i%4][i//4].imshow(faceimages[i], cmap="gray")
print("Showing sample faces")
plt.show()

# Print some details
faceshape = list(faces.values())[0].shape
print("Face image shape:", faceshape)

classes = set(filename.split(".")[0].split('_')[1] for filename in faces.keys())
print("Number of classes:", len(classes),classes)
print("Number of images:", len(faces))

faces_key = list(faces.keys())
test_keys = set()
for i in range(len(faces_key)):
    num=faces_key[i].split("_")[0]
    if int(num)%10==0:
        test_keys.add(faces_key[i])
#print(test_keys)


# Take classes 1-40 for eigenfaces, keep entire class 41 and
# image 10 of class 39 as out-of-sample test
facematrix = []
facelabel = []
for key,val in faces.items():
    if key in test_keys:
        continue # this is our test set
    facematrix.append(val.flatten())
    facelabel.append(key.split(".")[0].split("_")[1])

# test labels:
test_labels = []
test_images = []

for i in test_keys:
    test_images.append(i)
    test_labels.append( i.split(".")[0].split("_")[1] )
print("test_images:",test_images)
print("test_labels:",test_labels)

# Create a NxM matrix with N images and M pixels per image
facematrix = np.array(facematrix)

# Apply PCA and take first K principal components as eigenfaces
pca = PCA().fit(facematrix)

n_components = 50
eigenfaces = pca.components_[:n_components]

# Show the first 16 eigenfaces
fig, axes = plt.subplots(4,4,sharex=True,sharey=True,figsize=(8,10))
for i in range(16):
    axes[i%4][i//4].imshow(eigenfaces[i].reshape(faceshape), cmap="gray")
print("Showing the eigenfaces")
plt.show()

# Generate weights as a KxN matrix where K is the number of eigenfaces and N the number of samples
weights = eigenfaces @ (facematrix - pca.mean_).T
print("Shape of the weight matrix:", weights.shape)

result =[]
for i in test_images:
    #
    query = faces[i].reshape(1,-1)
    query_weight = eigenfaces @ (query - pca.mean_).T
    euclidean_distance = np.linalg.norm(weights - query_weight, axis=0)
    best_match = np.argmin(euclidean_distance)
    result.append(facelabel[best_match])
    print("Best match %s with Euclidean distance %f" % (facelabel[best_match], euclidean_distance[best_match]))
    # Visualize
    fig, axes = plt.subplots(1,2,sharex=True,sharey=True,figsize=(8,6))
    axes[0].imshow(query.reshape(faceshape), cmap="gray")
    axes[0].set_title("Query")
    axes[1].imshow(facematrix[best_match].reshape(faceshape), cmap="gray")
    axes[1].set_title("Best match")
    plt.show()

fig, axes = plt.subplots(1,2,sharex=True,sharey=True,figsize=(8,6))
axes[0].imshow(query.reshape(faceshape), cmap="gray")
axes[0].set_title("Query")
axes[1].imshow(facematrix[best_match].reshape(faceshape), cmap="gray")
axes[1].set_title("Best match")
plt.show()

import numpy as np
from sklearn.metrics import accuracy_score

acc = accuracy_score(test_labels, result) 
print("Accuracy is",acc)

from sklearn.metrics import confusion_matrix
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
y_test = test_labels
y_pred = result
cm = confusion_matrix(y_test, y_pred)
print("Confusion matrix:")
print(cm)
precision = precision_score(y_test, y_pred,average='macro')
print("Precision:")
print(precision)
recall = recall_score(y_test, y_pred,average='macro')
print("Recall:")
print(recall)
f1_score = f1_score(y_test, y_pred,average='macro')
print("F1 score:")
print(f1_score)